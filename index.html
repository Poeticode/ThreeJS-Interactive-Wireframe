<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js testing</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		<script src="js/dat.gui.min.js"></script>
		<div id="canvas-container"></div>
		<script>
		window.onload = function() {
			var camera, scene, renderer;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var objects = [];
			var raycaster;
			var mouse;
			var container;

			var box;
			var octahedron;
			var r = 255, g = 255, b = 255;

			var count = 0;

			// Variables that affect the sphere animation
			var SphereParams = new function() {
				this.x_frequency = 90;
				this.y_frequency = 60;
				this.z_frequency = 30;
				this.x_phase = 0;
				this.y_phase = 120;
				this.z_phase = 240; // 0.1
				this.x_amplitude = 0.775;
				this.y_amplitude = 0.1;
				this.z_amplitude = 0.1;
				this.x_center = 0.1;
				this.y_center = 0.1;
				this.z_center = 0.1;
				this.which_order = "y";
				this.x_rotation = 0.0003;
				this.y_rotation = 0.00002;
				this.z_rotation = 0.00002;
			};
			var BackgroundParams = new function() {
				this.r_frequency = 120;
				this.g_frequency = 120;
				this.b_frequency = 120;
				this.r_phase = 0;
				this.g_phase = 120; // 2*Math.PI/3
				this.b_phase = 240; // 4*Math.PI/3
			    this.r_amplitude = 127;
			    this.g_amplitude = 127;
			    this.b_amplitude = 127;
			    this.r_center = 128;
				this.g_center = 128;
				this.b_center = 128;
			}
			var MiscParams = new function() {
				this.count_increment = 0.0155;
				this.box_xrotate_speed = 0.001;
			}
			var gui = new dat.GUI();
			var sphereFolder = gui.addFolder('Sphere');
			// Frequency & Phase repeat after 2π radians (aka 360°)
			sphereFolder.add(SphereParams, 'x_frequency', 0, 360);
			sphereFolder.add(SphereParams, 'y_frequency', 0, 360);
			sphereFolder.add(SphereParams, 'z_frequency', 0, 360);
			sphereFolder.add(SphereParams, 'x_phase', 0, 360);
			sphereFolder.add(SphereParams, 'y_phase', 0, 360);
			sphereFolder.add(SphereParams, 'z_phase', 0, 360); //6.28318530718
			sphereFolder.add(SphereParams, 'x_amplitude', -5, 5);
			sphereFolder.add(SphereParams, 'y_amplitude', -5, 5);
			sphereFolder.add(SphereParams, 'z_amplitude', -5, 5);
			sphereFolder.add(SphereParams, 'x_center', -50, 50);
			sphereFolder.add(SphereParams, 'y_center', -50, 50);
			sphereFolder.add(SphereParams, 'z_center', -50, 50);
			sphereFolder.add(SphereParams, 'which_order',  [ 'x', 'y', 'z' ]);
			sphereFolder.add(SphereParams, 'x_rotation', -.5, .5);
			sphereFolder.add(SphereParams, 'y_rotation', -.5, .5);
			sphereFolder.add(SphereParams, 'z_rotation', -.5, .5);

			var backgroundFolder = gui.addFolder('Background');
			backgroundFolder.add(BackgroundParams, 'r_frequency', 0, 360);
			backgroundFolder.add(BackgroundParams, 'g_frequency', 0, 360);
			backgroundFolder.add(BackgroundParams, 'b_frequency', 0, 360);
			backgroundFolder.add(BackgroundParams, 'r_phase', 0, 360);
			backgroundFolder.add(BackgroundParams, 'g_phase', 0, 360);
			backgroundFolder.add(BackgroundParams, 'b_phase', 0, 360);

			// TODO: Surely there must be a way to modularize these controllers? Perhaps also the folders.
			var r_amp_controller = backgroundFolder.add(BackgroundParams, 'r_amplitude', 0, 127);
			r_amp_controller.onChange(function(value) {
				if (BackgroundParams.r_center + value > 255) {
					BackgroundParams.r_center = BackgroundParams.r_center - ( (BackgroundParams.r_center + value) - 255);
					updateDisplay(gui);
				} else if (BackgroundParams.r_center - value < 0) {
					BackgroundParams.r_center = BackgroundParams.r_center + ( Math.abs(BackgroundParams.r_center - value) );
					updateDisplay(gui);
				}
			});
			var g_amp_controller = backgroundFolder.add(BackgroundParams, 'g_amplitude', 0, 127);
			g_amp_controller.onChange(function(value) {
				if (BackgroundParams.g_center + value > 255) {
					BackgroundParams.g_center = BackgroundParams.g_center - ( (BackgroundParams.g_center + value) - 255);
					updateDisplay(gui);
				} else if (BackgroundParams.g_center - value < 0) {
					BackgroundParams.g_center = BackgroundParams.g_center + ( Math.abs(BackgroundParams.g_center - value) );
					updateDisplay(gui);
				}
			});
			var b_amp_controller = backgroundFolder.add(BackgroundParams, 'b_amplitude', 0, 127);
			b_amp_controller.onChange(function(value) {
				if (BackgroundParams.b_center + value > 255) {
					BackgroundParams.b_center = BackgroundParams.b_center - ( (BackgroundParams.b_center + value) - 255);
					updateDisplay(gui);
				} else if (BackgroundParams.b_center - value < 0) {
					BackgroundParams.b_center = BackgroundParams.b_center + ( Math.abs(BackgroundParams.b_center - value) );
					updateDisplay(gui);
				}
			});

			var r_center_controller = backgroundFolder.add(BackgroundParams, 'r_center', 0, 255);
			r_center_controller.onChange(function(value) { // amp 40, center 15
				if (BackgroundParams.r_amplitude + value > 255) {
					BackgroundParams.r_amplitude = BackgroundParams.r_amplitude - ( (BackgroundParams.r_amplitude + value) - 255);
					updateDisplay(gui);
				} else if (value - BackgroundParams.r_amplitude < 0) {
					BackgroundParams.r_amplitude = BackgroundParams.r_amplitude - Math.abs(value - BackgroundParams.r_amplitude);
					updateDisplay(gui);
				}
			});
			var g_center_controller = backgroundFolder.add(BackgroundParams, 'g_center', 0, 255);
			g_center_controller.onChange(function(value) {
				if (BackgroundParams.g_amplitude + value > 255) {
					BackgroundParams.g_amplitude = BackgroundParams.g_amplitude - ( (BackgroundParams.g_amplitude + value) - 255);
					updateDisplay(gui);
				} else if (value - BackgroundParams.g_amplitude < 0) {
					BackgroundParams.g_amplitude = BackgroundParams.g_amplitude - Math.abs(value - BackgroundParams.g_amplitude);
					updateDisplay(gui);
				}
			});
			var b_center_controller = backgroundFolder.add(BackgroundParams, 'b_center', 0, 255);
			b_center_controller.onChange(function(value) {
				if (BackgroundParams.b_amplitude + value > 255) {
					BackgroundParams.b_amplitude = BackgroundParams.b_amplitude - ( (BackgroundParams.b_amplitude + value) - 255);
					updateDisplay(gui);
				} else if (value - BackgroundParams.b_amplitude < 0) {
					BackgroundParams.b_amplitude = BackgroundParams.b_amplitude - Math.abs(value - BackgroundParams.b_amplitude);
					updateDisplay(gui);
				}
			});

			var miscFolder = gui.addFolder('Miscellaneous');
			miscFolder.add(MiscParams, 'count_increment',0,1.5);
			miscFolder.add(MiscParams, 'box_xrotate_speed', -1, 1);
			sphereFolder.open();

			// global properties of the sphere we can manipulate
			var sphere_geometry;
			var sphere_object;
			var x_positions = [];
			var y_positions = [];
			var z_positions = [];


			init();
			animate();

			/*
			 * Dat.GUI's listen function is buggy, so have to manually update the GUI after updating a value remotely
			 */
			function updateDisplay(gui) {
				for (var i in gui.__controllers) {
					gui.__controllers[i].updateDisplay();
				}
				for (var f in gui.__folders) {
					updateDisplay(gui.__folders[f]);
				}
			}
			function sphereCallback(obj) {
				// If you need to change the color of the sphere's wireframe, use this:
				// obj.material.color.setHex(0xd0d0d0);

				// The sphere's pretty small, so scale it by x15
				obj.scale.set(15,15,15);
				obj.name = "animated-sphere";
				// Get the sphere's mesh and geometry to manipulate them in the animate function
				sphere_object = obj;
				sphere_geometry = obj.geometry;

				var nVertices = sphere_geometry.vertices.length;
				var origVertices= new Array(nVertices);
				for(var i = 0; i < nVertices; i++){
					origVertices[i]	= sphere_geometry.vertices[i].clone();
					// Do a sorted add with the x-position of each vertex, along with their original index.
					binaryInsert([sphere_geometry.vertices[i].x,i],x_positions);
					binaryInsert([sphere_geometry.vertices[i].y,i],y_positions);
					binaryInsert([sphere_geometry.vertices[i].z,i],z_positions);
				}
				sphere_geometry._origVertices = origVertices.slice(0);
				scene.add(obj);
				objects.push(obj);
			}
			function init() {

				// Set up the camera to be inside the sphere, close to the edge
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 25000 );
				camera.position.x = 1000;
				camera.position.y = 0;

				// Set up the scene & light
				scene = new THREE.Scene();

				var light = new THREE.PointLight(0xffffff);
				light.intensity = 200;
				light.position.set(0,0,0);
				scene.add(light);

				// Make sure the camera's facing the right way (the closest side)
				camera.lookAt(new THREE.Vector3(2000,0,0));

				// Load up the fancy sphere. Note the callback function.
				var loader = new THREE.ObjectLoader();
				loader.load("models/sphere.json", sphereCallback);

				var geometry = new THREE.BoxGeometry( 175, 175, 175 );
				box = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, wireframe: true } ));
				box.position.x = 1300;
				box.position.z = -200;
				box.name = "box";
				scene.add(box);
				objects.push(box);

				octahedron = new THREE.Mesh (new THREE.OctahedronGeometry(100,0), new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, wireframe: true } ));
				octahedron.position.x = 1250;
				octahedron.position.z = 200;
				scene.add(octahedron);
				objects.push(octahedron);

				// Set up the renderer, append it to the #canvas-container
				renderer = new THREE.WebGLRenderer( { alpha: true } );
				//renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				container = document.getElementById("canvas-container");
				container.addEventListener( 'mousedown', onDocumentMouseDown, false );
				container.addEventListener( 'touchstart', onDocumentTouchStart, false );
				container.addEventListener( 'mousemove', onDocumentMouseMove, false );
				container.addEventListener( 'mousewheel', onDocumentMouseWheel, false);
				container.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onDocumentMouseWheel( event ) {
				var evt=window.event || e;
				var delta=evt.detail? evt.detail*(-120) : evt.wheelDelta; //delta returns +120 when wheel is scrolled up, -120 when scrolled down
			    camera.position.x=(delta<=-120)? camera.position.x-50 : camera.position.x+50; // zoom in or out, depending on whether wheel is scrolled up or down
			}
			function onDocumentTouchStart( event ) {
				var evt=window.event || e;
				//evt.preventDefault();
				evt.clientX = evt.touches[0].clientX;
				evt.clientY = evt.touches[0].clientY;
				onDocumentMouseDown( evt );
			}
			function onDocumentMouseMove( event ) {
				var evt=window.event || e;
				//event.preventDefault
				mouse.x = ( evt.clientX / renderer.domElement.width ) * 2 - 1;
				mouse.y = - ( evt.clientY / renderer.domElement.height ) * 2 + 1;
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( objects );
				if ( intersects.length > 0 ) {
					if ( intersects[ 0 ].object.name != "animated-sphere")
						container.style.cursor = "pointer";
					else
						container.style.cursor = "auto";
				} else {
					container.style.cursor = "auto";
				}
			}
			function onDocumentMouseDown( event ) {
				var evt=window.event || e;
				//event.preventDefault();
				mouse.x = ( evt.clientX / renderer.domElement.width ) * 2 - 1;
				mouse.y = - ( evt.clientY / renderer.domElement.height ) * 2 + 1;
				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( objects );
				if ( intersects.length > 0 ) {
					if (intersects[ 0 ].object.name != "animated-sphere") {
						intersects[ 0 ].object.material.wireframe = !intersects[ 0 ].object.material.wireframe;
						intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
					}
					if (intersects[ 0 ].object.name == "box")
						MiscParams.box_xrotate_speed = getRandom(0.1,-0.1);
				}
			}

			/* radians = degrees * (pi/180)
			 * degrees = radians * (180/pi)
			 */
			 function getRadians(degrees) {
			 	return degrees * (Math.PI/180);
			 }

			/*
			 * Determines whether the current background color is bright/dark.
			 * A bright color turns the sphere wireframe black. Dark turns it white.
			 */
			function getContrastYIQ(hexcolor){
				hexcolor.replace('#','');
				var red = parseInt(hexcolor.substr(0,2),16);
				var green = parseInt(hexcolor.substr(2,2),16);
				var blue = parseInt(hexcolor.substr(4,2),16);
				var yiq = ((red*299)+(green*587)+(blue*114))/1000;
				return (yiq >= 128) ? '0x000000' : '0xd0d0d0';
			}
			/*
			 * Helper function for getting random numbers within a specified range.
			 */
			function getRandom(max, min) {
				return Math.random() * (max - min) + min;
			}
			/*
			 * Helper functions for converting RGB <--> Hex, etc
			 */
			function RGB2Color(r,g,b)
			{
				return 'rgb(' + Math.round(r) + ',' + Math.round(g) + ',' + Math.round(b) + ')';
			}
			function componentToHex(c) {
				var hex = c.toString(16);
				return hex.length == 1 ? "0" + hex : hex;
			}
			function rgbToHex(red, green, blue) {
				var rgb = blue | (green << 8) | (red << 16);
				return (0x1000000 + rgb).toString(16).slice(1)
			}
			/*
			 * Binary Insert taken from Eloone @ github.com/eloone/11342252
			 * I use this to avoid using an expensive sort function on those vertex x/y/z array things
			*/
			function binaryInsert(value, array, startVal, endVal){
				var length = array.length;
				var start = typeof(startVal) != 'undefined' ? startVal : 0;
				var end = typeof(endVal) != 'undefined' ? endVal : length - 1;
				var m = start + Math.floor((end - start)/2);

				if(length == 0){
					array.push(value);
					return;
				}
				if(value > array[end]){
					array.splice(end + 1, 0, value);
					return;
				}
				if(value < array[start]){
					array.splice(start, 0, value);
					return;
				}
				if(start >= end){
					return;
				}
				if(value < array[m]){
					binaryInsert(value, array, start, m - 1);
					return;
				}
				if(value > array[m]){
					binaryInsert(value, array, m + 1, end);
					return;
				}

			}

			/*
			 * Keep the aspect ratio and stuff if the window is resized
			 */
			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			/*
			 * Main loop to handle animation
			 */
			function animate() {
				r = Math.sin( getRadians(BackgroundParams.r_frequency)*(-count) + getRadians(BackgroundParams.r_phase) ) * BackgroundParams.r_amplitude + BackgroundParams.r_center;
				g = Math.sin( getRadians(BackgroundParams.g_frequency)*(-count) + getRadians(BackgroundParams.g_phase) ) * BackgroundParams.g_amplitude + BackgroundParams.g_center;
				b = Math.sin( getRadians(BackgroundParams.b_frequency)*(-count) + getRadians(BackgroundParams.b_phase) ) * BackgroundParams.b_amplitude + BackgroundParams.b_center;
				var background_hex = RGB2Color(r,g,b);

				document.body.style.backgroundColor=background_hex;

				// Make sure the sphere has loaded
				if (sphere_geometry != null) {
					// setting dynamic to true lets you change the position of vertices
					sphere_geometry.dynamic = true;

					sphere_object.rotation.x += SphereParams.x_rotation;
					sphere_object.rotation.y += SphereParams.y_rotation;
					sphere_object.rotation.z += SphereParams.z_rotation;

					sphere_object.material.color.setHex( getContrastYIQ(rgbToHex(r, g, b)) );

					// Go through each vertex and change its x/y/z coordinate
					for (var j = 0; j < sphere_geometry.vertices.length; j++) {

						// Decide which axis it should go through in numeric order
						if (SphereParams.which_order == "x") {
							var origin = sphere_geometry._origVertices[x_positions[j][1]];
							var newPosition = sphere_geometry.vertices[x_positions[j][1]];
						} else if (SphereParams.which_order == "y") {
							var origin = sphere_geometry._origVertices[y_positions[j][1]];
							var newPosition = sphere_geometry.vertices[y_positions[j][1]];
						} else if (SphereParams.which_order == "z") {
							var origin = sphere_geometry._origVertices[z_positions[j][1]];
							var newPosition = sphere_geometry.vertices[z_positions[j][1]];
						}
						newPosition.y = origin.y+ (Math.sin( ( j+count  ) * getRadians(SphereParams.x_frequency) + getRadians(SphereParams.x_phase) ) * SphereParams.y_amplitude + SphereParams.x_center );
						newPosition.x = origin.x+ (Math.sin( ( j+count  ) * getRadians(SphereParams.y_frequency) + getRadians(SphereParams.y_phase) ) * SphereParams.x_amplitude + SphereParams.y_center );
						newPosition.z = origin.z+ (Math.sin( ( j+count  ) * getRadians(SphereParams.z_frequency) + getRadians(SphereParams.z_phase) ) * SphereParams.z_amplitude + SphereParams.z_center );
					}
					// Set the dirtyVertices flag so that the vertices will be updated in the renderer
					sphere_geometry.verticesNeedUpdate = true;
					sphere_geometry.__dirtyVertices = true;
				}

				box.rotation.x += MiscParams.box_xrotate_speed;
				box.rotation.z += Math.sin( (2.4*count) / 10 ) * 0.002;
				box.rotation.y += Math.sin( (1.4*count) / 5 ) * 0.008;
				octahedron.rotation.x += 0.01;

				// Render and repeat.
				render();
				requestAnimationFrame( animate );
			}
			function render() {
				renderer.render( scene, camera );
				count += MiscParams.count_increment;
			}
		};


		</script>
	</body>
</html>
