<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js testing</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}

		</style>
	</head>
	<body>
		<script src="js/three.js"></script>
		
		<script src="js/dat.gui.min.js"></script>
		<div id="canvas-container"></div>

		<script>
			/*
			 * Same as production except with keyboard controls to change the animation. Go to animate() section for keyboard layout
			 */
window.onload = function() {
			var camera, scene, renderer;
			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;
			var objects = [];
			var raycaster;
			var mouse;
			var container;

			var box;
			var octahedron;
			var r = 255, g = 255, b = 255;

			var count = 0;

			// Variables that affect the sphere animation
			var SphereParams = new function() {
				this.count_increment = 0.0155;
				this.x_amplitude = 0.775;
				this.y_amplitude = 0
				this.z_amplitude = 0;
				this.frequency = 0.5;
				this.whichOrder = "y";
				this.x_rotation = 0.0003;
				this.y_rotation = 0.00002;
				this.z_rotation = 0;
				this.box_xrotate_speed = 0.001;
			};

			var gui = new dat.GUI();
			gui.add(SphereParams, 'count_increment',0,5);
			gui.add(SphereParams, 'x_amplitude', -5, 5);
			gui.add(SphereParams, 'y_amplitude', -5, 5);
			gui.add(SphereParams, 'z_amplitude', -5, 5);
			gui.add(SphereParams, 'frequency', -5, 5);
			gui.add(SphereParams, 'whichOrder',  [ 'x', 'y', 'z' ]);
			gui.add(SphereParams, 'x_rotation', -1, 1);
			gui.add(SphereParams, 'y_rotation', -1, 1);
			gui.add(SphereParams, 'z_rotation', -1, 1);
			gui.add(SphereParams, 'box_xrotate_speed', -1, 1);

			// properties of the sphere we can manipulate
			var sphere_geometry;
			var sphere_object;
			var x_positions = [];
			var y_positions = [];
			var z_positions = [];

			
			init();
			animate();

			function sphereCallback(obj) {
				// If you need to change the color of the sphere's wireframe, use this:
				// obj.material.color.setHex(0xd0d0d0);

				// The sphere's pretty small, so scale it by x15
				obj.scale.set(15,15,15);
				obj.name = "animated-sphere";
				// Get the sphere's mesh and geometry to manipulate them in the animate function
				sphere_object = obj;
				sphere_geometry = obj.geometry;

				var nVertices = sphere_geometry.vertices.length;
				var origVertices= new Array(nVertices);
				for(var i = 0; i < nVertices; i++){
					origVertices[i]	= sphere_geometry.vertices[i].clone();
					// Do a sorted add with the x-position of each vertex, along with their original index.
					binaryInsert([sphere_geometry.vertices[i].x,i],x_positions);
					binaryInsert([sphere_geometry.vertices[i].y,i],y_positions);
					binaryInsert([sphere_geometry.vertices[i].z,i],z_positions);
				}
				sphere_geometry._origVertices = origVertices.slice(0);
				scene.add(obj);
				objects.push(obj);
				console.log(obj);
			}
			function init() {

				// Set up the camera to be inside the sphere, close to the edge
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, .1, 25000 );
				camera.position.x = 1000;
				camera.position.y = 0;

				// Set up the scene & light
				scene = new THREE.Scene();

				var light = new THREE.PointLight(0xffffff);
				light.intensity = 200;
				light.position.set(0,0,0);
				scene.add(light);

				// Make sure the camera's facing the right way (the closest side)
				camera.lookAt(new THREE.Vector3(2000,0,0));

				// Load up the fancy sphere. Note the callback function.
				var loader = new THREE.ObjectLoader();
				loader.load("models/sphere.json", sphereCallback);

				var geometry = new THREE.BoxGeometry( 175, 175, 175 );
				box = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, wireframe: true } ));
				box.position.x = 1300;
				box.position.z = -200;
				box.name = "box";
				scene.add(box);
				objects.push(box);

				octahedron = new THREE.Mesh (new THREE.OctahedronGeometry(100,0), new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff, wireframe: true } ));
				octahedron.position.x = 1250;
				octahedron.position.z = 200;
				scene.add(octahedron);
				objects.push(octahedron);

				// Set up the renderer, append it to the #canvas-container
				renderer = new THREE.WebGLRenderer( { alpha: true } );
				//renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );


				raycaster = new THREE.Raycaster();
				mouse = new THREE.Vector2();

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'mousewheel', onDocumentMouseWheel, false);

				// NOTE: This must run after the #canvas-container div is loaded, otherwise explosions.
				// This can be achieved by starting init() & animate() after window.onload
				// Or by placing this script after the #canvas-container div
				container = document.getElementById("canvas-container");
				container.appendChild( renderer.domElement );
				window.addEventListener( 'resize', onWindowResize, false );
			}
			function onDocumentMouseWheel( event ) {
				var evt=window.event || e;
				var delta=evt.detail? evt.detail*(-120) : evt.wheelDelta; //delta returns +120 when wheel is scrolled up, -120 when scrolled down
			    camera.position.x=(delta<=-120)? camera.position.x-50 : camera.position.x+50; // zoom in or out, depending on whether wheel is scrolled up or down
				if (evt.preventDefault) //disable default wheel action of scrolling page
					evt.preventDefault();
				else
					return false;

			}
			function onDocumentTouchStart( event ) {

				event.preventDefault();

				event.clientX = event.touches[0].clientX;
				event.clientY = event.touches[0].clientY;
				onDocumentMouseDown( event );

			}
			function onDocumentMouseMove( event ) {
				//event.preventDefault
				mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;
				raycaster.setFromCamera( mouse, camera );

				var intersects = raycaster.intersectObjects( objects );
				if ( intersects.length > 0 ) {
					if ( intersects[ 0 ].object.name != "animated-sphere")
						container.style.cursor = "pointer";
					else
						container.style.cursor = "auto";
				} else {
					container.style.cursor = "auto";
				}

			}
			function getContrastYIQ(hexcolor){
				hexcolor.replace('#','');
				var red = parseInt(hexcolor.substr(0,2),16);
				var green = parseInt(hexcolor.substr(2,2),16);
				var blue = parseInt(hexcolor.substr(4,2),16);
				var yiq = ((red*299)+(green*587)+(blue*114))/1000;
				return (yiq >= 128) ? '0x000000' : '0xd0d0d0';
			}
			function getRandom(max, min) {
				return Math.random() * (max - min) + min;
			}
			function onDocumentMouseDown( event ) {

				//event.preventDefault();

				mouse.x = ( event.clientX / renderer.domElement.width ) * 2 - 1;
				mouse.y = - ( event.clientY / renderer.domElement.height ) * 2 + 1;

				raycaster.setFromCamera( mouse, camera );
				var intersects = raycaster.intersectObjects( objects );
				if ( intersects.length > 0 ) {
					if (intersects[ 0 ].object.name != "animated-sphere") {
						intersects[ 0 ].object.material.wireframe = !intersects[ 0 ].object.material.wireframe;
						intersects[ 0 ].object.material.color.setHex( Math.random() * 0xffffff );
					}
					if (intersects[ 0 ].object.name == "box")
						SphereParams.box_xrotate_speed = getRandom(0.1,-0.1);
				}

			}
			function RGB2Color(r,g,b)
			{
				return 'rgb(' + Math.round(r) + ',' + Math.round(g) + ',' + Math.round(b) + ')';
			}
			function componentToHex(c) {
				var hex = c.toString(16);
				return hex.length == 1 ? "0" + hex : hex;
			}
			function rgbToHex(red, green, blue) {
				var rgb = blue | (green << 8) | (red << 16);
				return (0x1000000 + rgb).toString(16).slice(1)
			}
			/*
			 * Binary Insert taken from Eloone @ github.com/eloone/11342252
			 * I use this to avoid using an expensive sort function on those vertex x/y/z array things
			*/
			function binaryInsert(value, array, startVal, endVal){
				var length = array.length;
				var start = typeof(startVal) != 'undefined' ? startVal : 0;
				var end = typeof(endVal) != 'undefined' ? endVal : length - 1;
				var m = start + Math.floor((end - start)/2);

				if(length == 0){
					array.push(value);
					return;
				}
				if(value > array[end]){
					array.splice(end + 1, 0, value);
					return;
				}
				if(value < array[start]){
					array.splice(start, 0, value);
					return;
				}
				if(start >= end){
					return;
				}
				if(value < array[m]){
					binaryInsert(value, array, start, m - 1);
					return;
				}
				if(value > array[m]){
					binaryInsert(value, array, m + 1, end);
					return;
				}

			}

			/*
			 * Keep the aspect ratio and stuff if the window is resized
			 */
			function onWindowResize() {
				windowHalfX = window.innerWidth / 2;
				windowHalfY = window.innerHeight / 2;

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			/*
			 * Main loop to handle animation
			 */
			function animate() {
				var rgb_frequency = 0.1;
				var r_frequency = 1.666;
				var g_frequency = 2.666;
				var b_frequency = 3.666;
				var r_phase = 0;
				var g_phase = 2*Math.PI/3;
				var b_phase = 4*Math.PI/3;
				var rgb_center = 128;
			    var rgb_amplitude = 127;
				r = Math.sin( ( rgb_frequency*(-count) + r_phase ) / 1 ) * rgb_amplitude + rgb_center;
				g = Math.sin( ( rgb_frequency*(-count) + g_phase ) / 1 ) * rgb_amplitude + rgb_center;
				b = Math.sin( ( rgb_frequency*(-count) + b_phase ) / 1 ) * rgb_amplitude + rgb_center;
				var background_hex = RGB2Color(r,g,b);

				document.body.style.backgroundColor=background_hex;

				// Make sure the sphere has loaded
				if (sphere_geometry != null) {
					// setting dynamic to true lets you change the position of vertices
					sphere_geometry.dynamic = true;

					sphere_object.rotation.x += SphereParams.x_rotation;
					sphere_object.rotation.y += SphereParams.y_rotation;
					sphere_object.rotation.z += SphereParams.z_rotation;

					sphere_object.material.color.setHex( getContrastYIQ(rgbToHex(r, g, b)) );

					// Go through each vertex and change its x/y/z coordinate
					for (var j = 0; j < sphere_geometry.vertices.length; j++) {

						// Decide which axis it should go through in numeric order
						if (SphereParams.whichOrder == "x") {
							var origin = sphere_geometry._origVertices[x_positions[j][1]];
							var newPosition = sphere_geometry.vertices[x_positions[j][1]];
						} else if (SphereParams.whichOrder == "y") {
							var origin = sphere_geometry._origVertices[y_positions[j][1]];
							var newPosition = sphere_geometry.vertices[y_positions[j][1]];
						} else if (SphereParams.whichOrder == "z") {
							var origin = sphere_geometry._origVertices[z_positions[j][1]];
							var newPosition = sphere_geometry.vertices[z_positions[j][1]];
						}
						newPosition.y = origin.y+ (Math.sin( ( -j+count  ) * SphereParams.frequency ) * SphereParams.y_amplitude );
						newPosition.x = origin.x+ (Math.sin( ( -j+count  ) * SphereParams.frequency ) * SphereParams.x_amplitude );
						newPosition.z = origin.z+ (Math.sin( ( -j+count  ) * SphereParams.frequency ) * SphereParams.z_amplitude );
					}
					// Set the dirtyVertices flag so that the vertices will be updated in the renderer
					sphere_geometry.verticesNeedUpdate = true;
					sphere_geometry.__dirtyVertices = true;
				}

				box.rotation.x += SphereParams.box_xrotate_speed;
				box.rotation.z += Math.sin( ( 2.4*count ) / 10 ) * 0.002;
				box.rotation.y += Math.sin( (1.4*count)/5)*0.008;
				octahedron.rotation.x += 0.01;

				// Render and repeat.
				render();
				requestAnimationFrame( animate );
			}
			function render() {
				renderer.render( scene, camera );
				count += SphereParams.count_increment;
			}
		};


		</script>
	</body>
</html>
